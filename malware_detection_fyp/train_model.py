"""
Malware Detection Training Script
Advanced CNN model training for malware classification using binary visualization patterns.
Supports 26 malware classes with data augmentation and regularization techniques.
"""

import os
import sys
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from datetime import datetime
import json

# Add project root to path
sys.path.append(os.path.dirname(os.path.abspath(__file__)))

from src.data_loader import CorrectMalwareDataLoader
from src.model_builder import CorrectMalwareModelBuilder

def train_correct_malware_model():
    """Train the corrected malware detection model"""
    
    print("=" * 60)
    print("CYBERSHIELD AI - MALWARE DETECTION TRAINING")
    print("Advanced Neural Network Model Training")
    print("=" * 60)
    
    # Configuration - Anti-overfitting optimized
    config = {
        'data_dir': 'data',
        'dataset_root': 'data/raw/malimg_dataset',
        'target_size': (128, 128),  # Smaller size to reduce overfitting
        'batch_size': 32,  # Larger batch for better generalization
        'epochs': 50,  # More epochs with early stopping
        'learning_rate': 0.001,  # Standard learning rate
        'model_type': 'regularized',  # Use heavily regularized model
        'num_classes': 26,  # 25 malware families + 1 benign class
        'use_data_augmentation': True,  # Strong augmentation
        'validation_split': 0.2,
        'test_split': 0.1,
        'dropout_rate': 0.5,  # High dropout
        'l2_reg': 0.001  # L2 regularization
    }
    
    print(f"Configuration:")
    for key, value in config.items():
        print(f"  {key}: {value}")
    print()
    
    # Initialize data loader
    print("Initializing correct data loader...")
    data_loader = CorrectMalwareDataLoader(
        data_dir=config['data_dir'],
        target_size=config['target_size'],
        batch_size=config['batch_size']
    )
    
    # Check if dataset exists, if not create it
    train_csv = os.path.join(config['data_dir'], 'train_combined.csv')
    if not os.path.exists(train_csv):
        print("Dataset CSV files not found. Creating dataset...")
        malware_dir = config['dataset_root']
        benign_dir = os.path.join('data/raw', 'benign_imgs')  # Benign images location
        
        if not os.path.exists(malware_dir):
            print(f"Error: Malware dataset directory not found: {malware_dir}")
            print("Please ensure the dataset is properly extracted.")
            return
        
        data_loader.create_dataset_csv(malware_dir, benign_dir if os.path.exists(benign_dir) else None)
    
    # Setup data generators with augmentation
    print("Setting up data generators with augmentation...")
    try:
        # Use data/raw as root since it contains both malimg_dataset and benign_imgs
        dataset_root = 'data/raw'
        train_gen, val_gen, test_gen = data_loader.setup_generators(
            dataset_root, 
            use_augmentation=config['use_data_augmentation']
        )
    except Exception as e:
        print(f"Error setting up generators: {e}")
        print("Please check that the dataset directory structure is correct.")
        return
    
    # Get class weights for imbalanced dataset
    print("Calculating class weights...")
    class_weights = data_loader.get_class_weights()
    print(f"Class weights calculated for {len(class_weights)} classes")
    
    # Initialize model builder
    print("Building model...")
    model_builder = CorrectMalwareModelBuilder(
        input_shape=(*config['target_size'], 3),
        num_classes=config['num_classes']
    )
    
    # Build and compile model
    model = model_builder.build_cnn_model(model_type=config['model_type'])
    model = model_builder.compile_model(model, learning_rate=config['learning_rate'])
    
    # Display model summary
    model_stats = model_builder.get_model_summary(model)
    
    # Create callbacks
    os.makedirs('models', exist_ok=True)
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    model_save_path = f"models/correct_malware_model_{timestamp}.keras"
    callbacks = model_builder.create_callbacks(model_save_path)
    
    # Train the model
    print(f"\nStarting training for {config['epochs']} epochs...")
    print(f"Training samples: {train_gen.samples}")
    print(f"Validation samples: {val_gen.samples}")
    print(f"Steps per epoch: {train_gen.samples // config['batch_size']}")
    print(f"Validation steps: {val_gen.samples // config['batch_size']}")
    
    history = model.fit(
        train_gen,
        epochs=config['epochs'],
        validation_data=val_gen,
        callbacks=callbacks,
        class_weight=class_weights,
        verbose=1
    )
    
    # Save training history
    history_path = f"models/training_history_{timestamp}.json"
    with open(history_path, 'w') as f:
        # Convert numpy arrays to lists for JSON serialization
        history_dict = {key: [float(val) for val in values] for key, values in history.history.items()}
        json.dump(history_dict, f, indent=2)
    
    print(f"\nTraining completed!")
    print(f"Best model saved to: {model_save_path}")
    print(f"Training history saved to: {history_path}")
    
    # Evaluate on test set
    print("\nEvaluating on test set...")
    test_results = model.evaluate(test_gen, verbose=1)
    test_loss = test_results[0]
    test_accuracy = test_results[1]
    print(f"Test Loss: {test_loss:.4f}")
    print(f"Test Accuracy: {test_accuracy:.4f}")
    
    # Plot training history
    plot_training_history(history, timestamp)
    
    # Save final model info
    model_info = {
        'timestamp': timestamp,
        'config': config,
        'model_stats': {k: int(v) if isinstance(v, np.integer) else v for k, v in model_stats.items()},
        'test_accuracy': float(test_accuracy),
        'test_loss': float(test_loss),
        'class_mapping': {k: int(v) if isinstance(v, np.integer) else v for k, v in data_loader.class_index.items()}
    }
    
    info_path = f"models/model_info_{timestamp}.json"
    with open(info_path, 'w') as f:
        json.dump(model_info, f, indent=2)
    
    print(f"Model info saved to: {info_path}")
    
    return model, history, data_loader

def plot_training_history(history, timestamp):
    """Plot and save training history"""
    
    fig, axes = plt.subplots(2, 2, figsize=(15, 10))
    fig.suptitle('Correct Malware Detection Model Training History', fontsize=16)
    
    # Accuracy
    axes[0, 0].plot(history.history['accuracy'], label='Training Accuracy')
    axes[0, 0].plot(history.history['val_accuracy'], label='Validation Accuracy')
    axes[0, 0].set_title('Model Accuracy')
    axes[0, 0].set_xlabel('Epoch')
    axes[0, 0].set_ylabel('Accuracy')
    axes[0, 0].legend()
    axes[0, 0].grid(True)
    
    # Loss
    axes[0, 1].plot(history.history['loss'], label='Training Loss')
    axes[0, 1].plot(history.history['val_loss'], label='Validation Loss')
    axes[0, 1].set_title('Model Loss')
    axes[0, 1].set_xlabel('Epoch')
    axes[0, 1].set_ylabel('Loss')
    axes[0, 1].legend()
    axes[0, 1].grid(True)
    
    # Precision
    if 'precision' in history.history:
        axes[1, 0].plot(history.history['precision'], label='Training Precision')
        axes[1, 0].plot(history.history['val_precision'], label='Validation Precision')
        axes[1, 0].set_title('Model Precision')
        axes[1, 0].set_xlabel('Epoch')
        axes[1, 0].set_ylabel('Precision')
        axes[1, 0].legend()
        axes[1, 0].grid(True)
    
    # Recall
    if 'recall' in history.history:
        axes[1, 1].plot(history.history['recall'], label='Training Recall')
        axes[1, 1].plot(history.history['val_recall'], label='Validation Recall')
        axes[1, 1].set_title('Model Recall')
        axes[1, 1].set_xlabel('Epoch')
        axes[1, 1].set_ylabel('Recall')
        axes[1, 1].legend()
        axes[1, 1].grid(True)
    
    plt.tight_layout()
    
    # Save plot
    plot_path = f"models/training_history_{timestamp}.png"
    plt.savefig(plot_path, dpi=300, bbox_inches='tight')
    plt.show()
    
    print(f"Training plots saved to: {plot_path}")

if __name__ == "__main__":
    try:
        model, history, data_loader = train_correct_malware_model()
        print("\n" + "=" * 60)
        print("TRAINING COMPLETED SUCCESSFULLY!")
        print("CyberShield AI model ready for malware detection")
        print("Advanced binary pattern analysis enabled")
        print("=" * 60)
        
    except Exception as e:
        print(f"\nError during training: {e}")
        import traceback
        traceback.print_exc()